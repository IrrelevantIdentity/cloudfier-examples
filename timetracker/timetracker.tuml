package timetracker; 

apply kirra;
import mdd_types;
import invoicer;

class Client

    attribute name : String;

    attribute projects : Project[*];

    attribute invoices : Invoice[*];

    operation newProject(description : String) : Project;
    begin
        var newProject;
        newProject := new Project;
        newProject.description := description;
        link ClientProject(client := self, projects := newProject);
        return newProject;
    end;

    operation startInvoice() : Invoice;
    begin
        var newInvoice;
        newInvoice := new Invoice;
        link ClientInvoice(client := self, invoices := newInvoice);
        return newInvoice;
    end;
    
    derived attribute openInvoices : Invoice[*] := {
    	self.invoices.select((i : Invoice) : Boolean {
    	    i.open
    	})
	};
    
    static query withInvoicesToIssue() : Client[*];
    begin
        return Client extent.select((client : Client) : Boolean {
        	client.invoices.exists((i : Invoice) : Boolean {
        	    i.open
        	})
        });
    end;
    
    static query withInvoicesPending() : Client[*];
    begin
        return Client extent.select((client : Client) : Boolean {
        	client.invoices.exists((i : Invoice) : Boolean {
        	    i.pending
        	})
        });
    end;
end;

class Project

    attribute description : String;

    attribute reported : Entry[*];

    derived attribute toInvoice : Entry[*] := {
        self.reported.select((e : Entry) : Boolean { not e.invoiced })
    };

    readonly attribute client : Client;

    derived attribute unitsReported : Integer := {
        self.reported.sum((e : Entry) : Integer { e.units })
    };

    derived attribute unitsToInvoice : Integer := {
        self.toInvoice.sum((e : Entry) : Integer { e.units })
    };

    operation addEntry(units : Integer) : Entry;
    begin
        var newEntry;
        newEntry := new Entry;
        newEntry.units := units;
        link ProjectEntry(reported := newEntry, project := self);
        return newEntry;
    end; 
end;

class Invoice

    derived attribute number : String := {
        "" + self.issueDate.year() + "." + self.invoiceId
    };

    derived id attribute invoiceId : Integer;

    readonly attribute client : Client;

    attribute issueDate : Date := { Date#today() };

    attribute reported : Entry[*];

    derived attribute open : Boolean := { self.status == Status#Preparation };
    derived attribute pending : Boolean := { self.status == Status#Invoiced };        
    derived attribute paid : Boolean := { self.status == Status#Received };        

    attribute status : Status;

    required port invoicer : Invoicer;

    derived attribute totalUnits : Integer := {
        self.reported.sum((e : Entry) : Integer { e.units })
    };
    
    operation issue()
        (* Cannot issue an invoice that has no entry reported. *)
        precondition MustHaveEntry { not self.reported.isEmpty() };
    begin
        self.issueDate := Date#today();
    end;
    
    operation cancel();

    private operation sendInvoice();
    begin
        send InvoiceIssued() to self.invoicer;
    end;

    statemachine Status

        initial state Preparation
            transition on call(issue) to Invoiced;
            transition on call(cancel) to Cancelled;                        
        end;

        state Invoiced
            entry {
                self.sendInvoice();
            };

            transition on signal(InvoicePaid) to Received;
            transition on call(cancel) to Cancelled;            
        end;

        state Received end; 
        
        state Cancelled end;
    end;

end;

signal InvoicePaid
end;

class Entry

    attribute units : Integer := 1
        (* Entry must describe a positive number of units. *)
        invariant MustBePositive { self.units > 0 };

    attribute project : Project;

    attribute date : Date := { Date#today() };

    attribute memo : Memo[0, 1];

    derived attribute client : Client := { self.project.client };

    (* Entry can be only invoiced once. Cannot be set directly but via #submit *)
    readonly attribute invoice : Invoice[0, 1];

    derived attribute invoiced : Boolean := { not (self.invoice == null) };

    (* Submits this entry to a chosen invoice for the client. *)
    operation submit(invoice : Invoice)
        precondition AlreadyInvoiced { not self.invoiced }
        precondition WrongClient(invoice) {
            invoice.client == self.project.client
        }
        precondition InvoiceNotOpen(invoice) { invoice.open };
    begin
        self.invoice := invoice;
    end;
end;

composition ProjectEntry

    role Project.reported;

    role Entry.project;

end;

association InvoicedEntry

    role Invoice.reported;

    role Entry.invoice;

end;

association ClientProject

    role Client.projects;

    role Project.client;

end;

association ClientInvoice

    role Client.invoices;

    role Invoice.client;

end;

end.
