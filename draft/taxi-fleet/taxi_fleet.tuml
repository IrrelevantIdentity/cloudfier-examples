package taxi_fleet;

class Taxi

    attribute name : String;

    attribute shift : Shift;

    readonly attribute drivers : Driver[*]
        (* Too many drivers for this shift *)
        invariant { self.drivers.size() <= self.shift.shiftsPerDay };

    derived attribute driverCount : Integer := { self.drivers.size() };

    derived attribute full : Boolean := {
        self.driverCount >= self.shift.shiftsPerDay
    };

    derived attribute booked : Boolean := { self.driverCount > 0 };

    (* Create charges for every driver *)
    operation charge(date : Date[0,1])
        (* Not booked, can't charge *)
        precondition { self.booked };
    begin
        self.drivers.forEach((toCharge : Driver) {
            Charge#newCharge(self.name, self.shift.price, toCharge, date);
        });
    end;
end;

association TaxisDrivers

    role Taxi.drivers;

    role Driver.taxis;

end;

class Shift

    attribute description : String;

    attribute price : Double;

    attribute shiftsPerDay : Integer := 1
        (* Choose at least 1 shift per day *)
        invariant { self.shiftsPerDay > 0 }
        (* Too many shifts per day *)
        invariant { self.shiftsPerDay <= 2 };
end;

class Driver

    attribute name : String;

    readonly attribute taxis : Taxi[*];

    readonly attribute charges : Charge[*];

    derived attribute hasBooking : Boolean := { not self.taxis.isEmpty() };

    derived attribute pendingCharges : Charge[*] := { self.charges.select((c : Charge) : Boolean { not c.paid }) };

    derived attribute paymentDue : Boolean := { not self.pendingCharges.isEmpty() };

    (* Book a taxi that is currently available *)
    operation book(toRent : Taxi)
        (* No taxis available *)
        precondition {
            Taxi extent.exists((t : Taxi) : Boolean { not t.full })
        }
        (* Driver already booked this taxi *)
        precondition (toRent) { not self.taxis.includes(toRent) }
        (* Taxi is not available *)
        precondition (toRent) { not toRent.full };
    begin
        link TaxisDrivers(taxis := toRent, drivers := self);
    end;

    (* Release a taxi that is currently booked *)
    operation release(toRelease : Taxi)
        (* No bookings to release *)
        precondition { self.hasBooking }
        (* Taxi not booked, can't release *)
        precondition (toRelease) { self.taxis.includes(toRelease) };
    begin
        unlink TaxisDrivers(taxis := toRelease, drivers := self);
    end;
end;

class Charge

    readonly attribute date : Date;

    readonly attribute receivedOn : Date[0, 1];

    readonly attribute driver : Driver;

    readonly attribute description : String;

    readonly attribute amount : Double;

    attribute status : Status;

    derived attribute paid : Boolean := { self.status == Status#Paid };

    operation pay();

    static operation newCharge(description : String, amount : Double, payer : Driver, 
            date : Date);
    begin
        var charge : Charge;
        if (date == null) then
            date := Date#today();
        charge := new Charge;
        charge.description := description;
        charge.amount := amount;
        link DriverCharges(driver := payer, charges := charge);
    end;

    static query pendingCharges() : Charge[*];
    begin
        return Charge extent.select((c : Charge) : Boolean { c.paid });
    end;

    statemachine Status

        initial state Pending
            transition on call(pay) to Paid;
        end;

        state Paid
            entry {
                self.receivedOn := Date#today();
            };
        end;

    end;

end;

association DriverCharges

    role Driver.charges;

    role Charge.driver;

end;

end.