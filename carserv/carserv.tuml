/*
  Model initially reverse engineered from the CarServ 
  sample application that appears in the book
  book Domain-Driven Design Using Naked Objects
  by Dan Haywood.
  
  http://pragprog.com/book/dhnako/domain-driven-design-using-naked-objects
  
  See Example Applications in the documentation for more information:

    http://cloudfier.com/doc/
*/
package carserv;

import mdd_types;

[kirra::User]
abstract class Person

    derived attribute fullName : String := {
        self.firstName + " " + self.lastName
    };

    attribute firstName : String;

    attribute lastName : String;
end;

enumeration Title
    Mr, 
    Mrs, 
    Ms
end;

class AutoMechanic specializes Person

    access { System#user() is AutoMechanic };

    attribute status : WorkingStatus;

    derived attribute working : Boolean := {
        self.status == WorkingStatus#Working
    };

    private attribute services : Service[*];

    (* Services currently in progress by this worker. *)
    derived attribute currentServices : Service[*] := {
        Service#byStatus(self.services, Service::Status#InProgress)
    };

    (* Services assigned to this worker but not yet started. *)
    derived attribute upcomingServices : Service[*] := {
        Service#byStatus(self.services, Service::Status#Booked)
    };

    derived attribute workInProgress : Boolean := {
        not self.currentServices.isEmpty()
    };

    derived attribute workScheduled : Boolean := {
        not self.upcomingServices.isEmpty()
    };

    (* Unassigns any work scheduled. Does not affect work in progress. *)
    operation unassign()
        precondition NoWorkScheduled { self.workScheduled };
    begin
        self.doUnassign();
    end;

    private operation doUnassign();
    begin
        self.upcomingServices.forEach((s : Service) {
            unlink TechnicianWorksOnService(services := s, technician := self);
        });
    end;

    (* Puts employee into vacation. Unassigns any work scheduled. *)
    operation beginVacation()
        precondition NoWorkInProgress { not self.workInProgress };
    begin
    end;

    (* Brings the employee back from vacation. Employee can be assigned work again. *)
    operation endVacation();

    operation retire()
        precondition NoWorkInProgress { not self.workInProgress };
    begin
    end;

    statemachine WorkingStatus

        initial state Working
            transition on call(beginVacation) to Vacation;
            transition on call(retire) to Retired;
        end;

        state Vacation
            transition on call(endVacation) to Working;
        end;

        state Retired end;

    end;

end;

class Customer specializes Person

    access {
        (System#user() == self) or (System#user() is AutoMechanic)
    };

    attribute cars : Car[0, *];

    attribute title : Title;

    derived attribute pendingServices : Service[*] := {
        self.cars.reduce((c : Car, soFar : Service[*]) : Service[*] {
            c.pendingServices.union(soFar)
        }, Service[])
    };

    derived attribute completedServices : Service[*] := {
        self.cars.reduce((c : Car, soFar : Service[*]) : Service[*] {
            c.completedServices.union(soFar)
        }, Service[])
    };

    (* A valuable customer is a customer that has two or more cars with us *)
    derived attribute vip : Boolean := { self.cars.size() >= 2 };

    static operation findByName(firstName : String[0, 1], lastName : String[0, 1]) : Customer[*]
        precondition OneMustBeProvided(firstName, lastName) {
            not ((firstName == null) and (lastName == null))
        };
    begin
        return Customer extent.select((c : Customer) : Boolean {
            (c.firstName = firstName) or (c.lastName = lastName)
        });
    end;

    static operation vipCustomers() : Customer[*];
    begin
        return Customer extent.select((c : Customer) : Boolean { c.vip });
    end;
end;

association TechnicianWorksOnService

    role Service.technician;

    role AutoMechanic.services;

end;

class Car

    access {
        (System#user() == self.owner) or (System#user() is AutoMechanic)
    };

    attribute registrationNumber : String;

    private readonly attribute services : Service[*];

    attribute \model : Model;

    attribute owner : Customer;

    derived attribute modelName : String := { self.\model.makeAndModel() };

    derived attribute pending : Integer := { self.pendingServices.size() };

    derived attribute pendingServices : Service[*] := {
        self.services.select((s : Service) : Boolean { s.pending })
    };

    derived attribute completedServices : Service[*] := {
        self.services.select((s : Service) : Boolean { not s.pending })
    };

    operation registrationAndModel() : String;
    begin
        return self.\model.makeAndModel() + " " + self.registrationNumber;
    end;

    static operation findByRegistrationNumber(regNumber : String) : Car[0, 1];
    begin
        return Car extent.\any((c : Car) : Boolean {
            regNumber = c.registrationNumber
        });
    end;

    (* Book a service on this car. *)
    operation bookService(description : Memo, estimateInDays : Integer);
    begin
        Service#newService(self, description, estimateInDays);
    end;

    static operation findByOwner(owner : Customer) : Car[*];
    begin
        return owner.cars;
    end;
end;

class Service

    access {
        (System#user() == self.car.owner) or (System#user() is AutoMechanic)
    };

    attribute description : Memo;

    attribute car : Car;

    readonly attribute bookedOn : Date := { Date#today() };

    attribute estimatedReady : Date := { Date#today().transpose(1) }
        invariant DeliveryDateMustBeAfterBookDate {
            ((self.estimatedReady == null) or (self.bookedOn == null)) or (self.estimatedDays >= 0)
        };

    derived attribute pending : Boolean := {
        (self.status == Status#Booked) or (self.status == Status#InProgress)
    };

    attribute technician : AutoMechanic[0, 1];

    attribute status : Status;

    derived attribute estimatedDays : Integer := {
        self.bookedOn.differenceInDays(self.estimatedReady)
    };

    derived attribute assigned : Boolean := { not (self.technician == null) };

    static query byStatus(services : Service[*], toMatch : Status) : Service[*];
    begin
        return services.select((service : Service) : Boolean {
            service.status == toMatch
        });
    end;

    static operation newService(carToService : Car, description : Memo, estimate : Integer) : Service
        precondition EstimateMustBePositive(estimate) { estimate > 0 };
    begin
        var s : Service;
        s := new Service;
        s.estimatedReady := s.bookedOn.transpose(estimate);
        s.description := description;
        s.car := carToService;
        return s;
    end;

    (* Cancels a service. No record is kept of cancelled services. *)
    operation cancel();
    begin
        destroy self;
    end;

    (* Starts the service. It can no longer be canceled. *)
    operation start()
        precondition { self.assigned };
    begin
    end;

    (* Completes the service. *)
    operation complete();
    begin
    end;

    (* Assigns a service that is available to a technician. *)
    operation assignTo(technician : AutoMechanic)
        precondition MustBePending { self.pending }
        precondition MustNotBeAssigned { ! self.assigned }
        precondition TechnicianMustBeWorking(technician) { technician.working };
    begin
        self.technician := technician;
    end;

    (* Assigns a service to a different technician other than the one currently assigned. *)
    operation transfer(mechanic : AutoMechanic)
        precondition MustBePending { self.pending }
        precondition MustBeAssigned { self.assigned }
        precondition AlreadyAssigned(mechanic) {
            not (self.technician == mechanic)
        }
        precondition TechnicianMustBeWorking(mechanic) { mechanic.working };
    begin
        self.technician := mechanic;
    end;

    statemachine Status

        initial state Booked
            transition on call(cancel) to Cancelled;
            transition on call(start) to InProgress;
        end;

        state InProgress
            transition on call(complete) to Completed;
        end;

        terminate state Completed end;

        terminate state Cancelled end;

    end;

end;

association CarOwner

    role Customer.cars;

    role Car.owner;

end;

composition ServiceCar

    role Car.services;

    role Service.car;

end;

class Make

    attribute name : String;
end;

class Model

    attribute name : String;

    attribute make : Make;

    query makeAndModel() : String;
    begin
        return self.make.name + " " + self.name;
    end;
end;

association

    role models : Model[*];

    role Model.make;

end;

end.