/*
  Model reverse engineered from the CarServ 
  sample application that appears in the book
  book Domain-Driven Design Using Naked Objects
  by Dan Haywood.
  
  http://pragprog.com/book/dhnako/domain-driven-design-using-naked-objects
  
  See Example Applications in the documentation for more information:

    http://cloudfier.com/doc/
*/
package carserv;

import mdd_types;

[kirra::User]
abstract class Person
    derived attribute fullName : String := {self.firstName + " " + self.lastName};
    attribute firstName : String;
    attribute lastName : String;
end;

class AutoMechanic specializes Person
    access{System#user()is AutoMechanic};
end;

class Customer specializes Person
    access{(System#user() == self) or (System#user()is AutoMechanic)};
    attribute title : Title[0, 1];
    attribute cars : Car[0, *];
    attribute since : Date := {Date#today()};
    /* TODO := Date#today(); */
    readonly attribute notes : Memo[0, 1];
    derived attribute valuableCustomer : Boolean := {self.cars.size() >= 2};
    derived attribute ownsACar : Boolean := {not self.cars.isEmpty()};
    operation addNotes(notes : Memo);
        precondition MustOwnACar{self.ownsACar}
    begin
        self.notes := notes;
    end;
    operation clearNotes();
        precondition MustOwnACar{self.notes != null}
    begin
        self.notes := null;
    end;
    static operation findByName(firstName : String[0, 1], lastName : String[0, 1]) : Customer[*];
        precondition(firstName, lastName){not((firstName == null) and (lastName == null))}
    begin
        return Customer extent.select((c : Customer) : Boolean {
            return(c.firstName = firstName) or (c.lastName = lastName);
        });
    end;
    static operation valuableCustomers() : Customer[*];
    begin
        return Customer extent.select((c : Customer) : Boolean {
            return c.valuableCustomer;
        });
    end;
end;

enumeration Gender
    Male, 
    Female
end;

class Title
    attribute name : String;
    attribute gender : Gender[0, 1];
end;

class Service
    access{(System#user() == self.car.owner) or (System#user()is AutoMechanic)};
    attribute description : Memo;
    attribute car : Car;
    readonly private attribute pending : Boolean := true;
    readonly attribute bookedOn : Date := {Date#today()};
    attribute estimatedReady : Date invariant DeliveryDateMustBeAfterBookDate{((self.bookedOn == null) or (self.estimatedReady == null)) or (self.estimatedDays >= 0)};
    reference technician : AutoMechanic[0, 1];
    attribute status : Status;
    derived attribute estimatedDays : Integer := {self.bookedOn.differenceInDays(self.estimatedReady)};
    static operation newService(carToService : Car, description : Memo, estimate : Integer) : Service;
        precondition(estimate){estimate > 0}
    begin
        var s : Service;
        s := new Service;
        s.estimatedReady := s.bookedOn.transpose(estimate);
        s.description := description;
        s.car := carToService;
        return s;
    end;
    (* Cancels a service. No record is kept of cancelled services. *)
    operation cancel();
    begin
        destroy self;
    end;
    (* Starts the service. It can no longer be canceled. *)
    operation start();
    begin
    end;
    (* Completes the service. *)
    operation complete();
    begin
        self.pending := false;
    end;
    statemachine Status initial state Booked transition on call(cancel)to Cancelled transition on call(start)to InProgress;state InProgress transition on call(complete)to Completed;terminate state Completed;terminate state Cancelled;end;
end;

class Car
    access{(System#user() == self.owner) or (System#user()is AutoMechanic)};
    attribute registrationNumber : String;
    readonly attribute services : Service[*];
    attribute \model : Model;
    attribute owner : Customer;
    derived attribute modelName : String := {self.\model.makeAndModel()};
    derived attribute pending : Integer := {self.pendingServices.size()};
    derived attribute pendingServices : Service[*] := {self.services.select((s : Service) : Boolean {
        return s.pending;
    })};
    operation registrationAndModel() : String;
    begin
        return self.\model.makeAndModel() + " " + self.registrationNumber;
    end;
    static operation findByRegistrationNumber(regNumber : String) : Car[0, 1];
    begin
        return Car extent.\any((c : Car) : Boolean {
            return regNumber = c.registrationNumber;
        });
    end;
    (* Book a service on this car. *)
    operation bookService(description : Memo, estimateInDays : Integer);
    begin
        Service#newService(self, description, estimateInDays);
    end;
    static operation findByOwner(owner : Customer) : Car[*];
    begin
        return owner.cars;
    end;
end;

association CarOwner
    role Customer.cars;
    role Car.owner;
end;

composition ServiceCar
    role Car.services;
    role Service.car;
end;

class Make
    attribute name : String;
end;

class Model
    attribute name : String;
    attribute make : Make;
    operation makeAndModel() : String;
 {
        return self.make.name + " " + self.name;
    };
end;

association
    role models : Model[*];
    role Model.make;
end;

end.