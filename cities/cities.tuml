package cities;

apply kirra;
import mdd_types;

class City

    attribute name : String;

    attribute population : Integer;

    attribute cityState : State;
end;

datatype StatePopulation

    attribute abbreviation : String;

    attribute population : Integer;
end;

class State

    attribute name : String;

    attribute abbreviation : String;

    attribute cities : City[*];

    derived attribute population : Integer := {
        self.cities.sum((c : City) : Integer { c.population })
    };

    query city(name : String) : City[0, 1];
    begin
        return self.cities.\any((c : City) : Boolean { c.name = name });
    end;
    
    static query citiesByState() : { stateAcronym : String, cities : City[*] }[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { stateAcronym  : String, cities : City[*]} {
            {
                stateAcronym := cities.one().cityState.abbreviation, 
                cities := cities
            }
        });
    end;

    static query byAbbreviation(abbreviation : String) : State[0, 1];
    begin
        return State extent.\any((s : State) : Boolean {
            s.abbreviation = abbreviation
        });
    end;

    static query statesMorePopulousThan(threshold : Integer) : State[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { : State,  : Integer} {
            {
                cityState := cities.one().cityState, 
                statePopulation := cities.sum((c : City) : Integer {
                    c.population
                })
            }
        }).select((aggregated : { : State, statePopulation : Integer}) : Boolean {
            aggregated.statePopulation > threshold
        }).collect((stats : {cityState : State,  : Integer}) : State {
            stats.cityState
        });
    end;

    static query abbreviationsOfStatesMorePopulousThan(threshold : Integer) : String[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { : String,  : Integer} {
            {
                cityState := cities.one().cityState.abbreviation, 
                statePopulation := cities.sum((c : City) : Integer {
                    c.population
                })
            }
        }).select((aggregated : { : String, statePopulation : Integer}) : Boolean {
            aggregated.statePopulation > threshold
        }).collect((aggregated : { cityState : String, statePopulation : Integer}) : String {
        	aggregated.cityState
        });
    end;

    static query statePopulations() : StatePopulation[*];
    begin
        return State extent.collect((cityState : State) : StatePopulation {
            ({
                abbreviation := cityState.abbreviation, 
                population := cityState.population
            } as StatePopulation)
        });
    end;
    
    static query statePopulations2() : StatePopulation[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : StatePopulation {
            {
                abbreviation := cities.one().cityState.abbreviation, 
                population := cities.sum((c : City) : Integer { c.population })
            }
        });
    end;
end;

aggregation CityStates

    role City.cityState;

    role State.cities;

end;

end.