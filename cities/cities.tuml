package cities;

apply kirra;
import mdd_types;

class City

    attribute name : String;

    attribute population : Integer;

    attribute cityState : State;
    
    static query citiesMorePopulousThan(threshold : Integer) : Integer;
    begin
        return City extent.select((c : City) : Boolean { c.population >= threshold } ).size();
    end;

    static query maximumPopulation() : Integer;
    begin
        return City extent.max((c : City) : Integer { c.population } );
    end;
    
    static query mostPopulousCity() : City;
    begin
        return City extent.maxElement((c : City) : Integer { c.population } );
    end;
end;

datatype StatePopulation

    attribute abbreviation : String;

    attribute population : Integer;
end;

class State

    attribute name : String;

    attribute abbreviation : String;

    attribute cities : City[*];

    derived attribute population : Integer := {
        self.cities.sum((c : City) : Integer { c.population })
    };

    query city(name : String) : City[0, 1];
    begin
        return self.cities.\any((c : City) : Boolean { c.name = name });
    end;
    
    static query citiesByState() : { stateAcronym : String, cities : City[*] }[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { stateAcronym  : String, cities : City[*]} {
            {
                stateAcronym := cities.one().cityState.abbreviation, 
                cities := cities
            }
        });
    end;

    static query byAbbreviation(abbreviation : String) : State[0, 1];
    begin
        return State extent.\any((s : State) : Boolean {
            s.abbreviation = abbreviation
        });
    end;

    static query statePopulationsAbove(threshold : Integer) : { \state : State, statePopulation : Integer}[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { : State,  : Integer} {
            {
                aState := cities.one().cityState, 
                statePopulation := cities.sum((c : City) : Integer {
                    c.population
                })
            }
        }).select((aggregated : { : State, statePopulation : Integer}) : Boolean {
            aggregated.statePopulation > threshold
        });
    end;


    static query statesMorePopulousThan(threshold : Integer) : State[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { : State,  : Integer} {
            {
                aState := cities.one().cityState, 
                statePopulation := cities.sum((c : City) : Integer {
                    c.population
                })
            }
        }).select((aggregated : { : State, statePopulation : Integer}) : Boolean {
            aggregated.statePopulation > threshold
        }).collect((stats : {theState : State,  : Integer}) : State {
        	/* 
        	 * Since we are in aggregated mode, going back to instances would require maybe
        	 * an outer query that maps the ids of states here to state instances.
        	 * IOW, if you are grouping by an instance, you are actually grouping by the
        	 * id of that instance , and getting the instances back requires some
        	 * legwork.
        	 * 
        	 * Also, generated tuple classes that include slots that are instances should map
        	 * to ids (the type of the primary key).
        	 */
        	  
            stats.theState
        });
    end;

    static query abbreviationsOfStatesMorePopulousThan(threshold : Integer) : String[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : { cityState : String, : Integer} {
            {
                cityState := cities.one().cityState.abbreviation, 
                statePopulation := cities.sum((c : City) : Integer {
                    c.population
                })
            }
        }).select((aggregated : { : String, statePop : Integer}) : Boolean {
            aggregated.statePop > threshold
        }).collect((aggregated : { cityState : String, statePopulation : Integer}) : String {
        	aggregated.cityState
        });
    end;

    static query statePopulations() : StatePopulation[*];
    begin
        return State extent.collect((cityState : State) : StatePopulation {
            ({
                abbreviation := cityState.abbreviation, 
                population := cityState.population
            } as StatePopulation)
        });
    end;
    
    static query statePopulations2() : StatePopulation[*];
    begin
        return City extent.groupBy((c : City) : State {
        	c.cityState
    	}).groupCollect((cities : City[*]) : StatePopulation {
            {
                abbreviation := cities.one().cityState.abbreviation, 
                population := cities.sum((c : City) : Integer { c.population })
            }
        });
    end;
end;

aggregation CityStates

    role City.cityState;

    role State.cities;

end;

end.