/*
 * See Example Applications in the documentation for more information:
 *
 * http://cloudfier.com/doc/
 */
package shipit;

[kirra::User]
class User
    attribute username : String;
    attribute fullName : String;
    attribute kind : UserKind;
    private derived static attribute current : User := { (System#user() as User) };
    private derived attribute committer : Boolean := { self.kind = UserKind#Committer };
    private attribute issuesAssignedToUser : Issue[*];
    readonly attribute issuesReportedByUser : Issue[*];    
    derived attribute issuesCurrentlyInProgress : Issue[*] := { Issue#byStatus(self.issuesAssignedToUser, Issue::Status#InProgress) };
    derived attribute issuesCurrentlyAssigned : Issue[*] := { Issue#byStatus(self.issuesAssignedToUser, Issue::Status#Assigned) };    
end;

enumeration UserKind 
    Reporter, Committer
end;

enumeration Severity
    Minor, 
    Normal, 
    Major, 
    Blocker,
    Enhancement
end;

enumeration Resolution
    Fixed, 
    WorksForMe, 
    WontFix 
end;

class Comment
    readonly attribute commented : Memo;
    readonly reference user : User;
    readonly attribute \on : Date;
    readonly attribute inReplyTo : Comment[0,1];
    readonly attribute issue : Issue;
    operation reply(text: Memo);
    begin
        self.issue.addComment(text, self);
    end;
end;

class Label
    attribute text : String;
end;

association IssueLabels 
    role Issue.labels;
    role labeled : Issue[*];
end;

association AssignedIssue
    role Issue.assignee;
    role User.issuesAssignedToUser;
end;    

association ReportedIssue
    role Issue.reporter;
    role User.issuesReportedByUser;
end;    

association WatchedIssues
    role Issue.watchers;
    navigable role issuesWatched : Issue[*];
end;

class Issue
    attribute summary : String;
    attribute labels : Label[*];    
    
    readonly attribute reportedOn : Date := { Date#today() };
    readonly attribute reporter : User;
    readonly attribute assignee : User[0,1];
    attribute severity : Severity;
    attribute status : Status;
    
    readonly attribute resolution : Resolution[0,1];
    readonly attribute resolvedOn : Date[0,1];
    readonly attribute comments : Comment[*];
    
    attribute watchers : User[*];
    
    derived attribute commentCount : Integer := { self.comments.size() };    
    derived attribute waitingFor : String := { 
        "" + self.reportedOn.differenceInDays(self.referenceDate()) + " day(s)"
    };
    
    private derived attribute mine : Boolean := { System#user() == self.assignee };
    private derived attribute free : Boolean := { self.assignee == null };
    private operation referenceDate() : Date;
    begin
        if (self.resolvedOn == null) then
            return Date#today()
        else
            return self.resolvedOn;
    end;
    attribute description : Memo;
    
    (* Report a new issue. *)
    static operation reportIssue(summary : String, description : Memo, severity : Severity := Normal);
    begin
        var newIssue : Issue;
        newIssue := new Issue;
        newIssue.summary := summary;
        newIssue.description := description;
        newIssue.severity := severity;
        newIssue.reporter := (System#user() as User);
    end;
    
    static operation bySeverity(toMatch : Severity) : Issue[*];
    begin
        return Issue extent.select((i : Issue) : Boolean { return i.severity = toMatch });
    end;

    static operation byStatus(issues : Issue[*], toMatch : Status) : Issue[*];    
    begin
	    return issues.select((issue : Issue) : Boolean {
            return issue.status == toMatch
        });
    end;
    
    (* Release the issue so another committer can work on it. *)        
    operation release();
    precondition { self.mine }    
    begin
        self.assignee := null;
    end;

    (* Assign an issue to a user. *)    
    operation assign(newAssignee : User);
    precondition { self.mine or self.free }    
    begin
        self.assignee := newAssignee;
    end;
    
    (* Suspend work on this issue. *)
    operation suspend();
    precondition { self.mine }        
    
    (* Start/resume work on this issue. *)
    operation start();
    precondition { self.mine }        

    (* Resolve the issue. *)        
    operation resolve(resolution : Resolution := Fixed);
    precondition { self.mine or self.free }
    begin
        self.resolvedOn := Date#today();
        self.resolution := resolution;
    end;

    (* Reopen the issue. *)    
    operation reopen(reason : Memo);
    begin
        self.resolvedOn := null;
        self.resolution := null;        
        if (reason != "") then
            self.comment(reason);        
    end;
    
    (* Add a comment to the issue *)
    operation comment(text : Memo);
    begin
        self.addComment(text, null);
    end;
    
    private operation addComment(text : Memo, inReplyTo : Comment);
    begin
        var comment : Comment;
        comment := new Comment;
        comment.user := User#current;
        comment.\on := Date#today();
        comment.commented := text;
        comment.inReplyTo := inReplyTo;
        link IssueComments(issue := self, comments := comment);
    end;
    
    (* Take over an issue currently available. *)
    operation assignToMe();
    precondition { User#current.committer }
    precondition { not self.mine }
    begin
        self.assignee := User#current;
    end;

    (* Take over an issue currently assigned to another user (not in progress). *)    
    operation steal();
    precondition { User#current.committer }
    precondition { not(self.mine) }
    begin
        self.assignee := User#current;
    end;
    
    (* Close the issue marking it as verified. *)
    operation verify();
    begin
    end; 

    statemachine Status 
        initial state Open
            transition on call(resolve) to Resolved
            transition on call(assignToMe) to Assigned
            transition on call(assign) to Assigned;
            
        state InProgress
            transition on call(suspend) to Assigned;
            
        state Assigned
            transition on call(release) to Open 
            transition on call(resolve) to Resolved
            transition on call(steal) to Assigned
            transition on call(start) to InProgress;
            
        state Resolved 
            transition on call(verify) to Verified 
            transition on call(reopen) to Open;
            
        state Verified
            transition on call(reopen) to Open;
    end;
end;

composition IssueComments
    role Issue.comments;
    role Comment.issue;
end;


end.
