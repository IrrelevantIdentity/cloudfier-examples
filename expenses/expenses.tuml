package expenses;

import payment;

(* The category for an expense. *)
class Category

    attribute name : String;

    static operation newCategory(name : String) : Category;
    begin 
        var newCategory : Category;
        newCategory := new Category;
        newCategory.name := name;
        return newCategory;
    end; 

    derived attribute expensesInThisCategory : Expense[*] := {
        Expense#findExpensesByCategory(self)
    };
end;

(* The expense as reported by an employee. *)
class Expense 

    derived attribute moniker : String := {
        self.description + " on " + self.date
    };

    readonly attribute description : String;

    readonly reference category : Category;

    readonly attribute status : Status;

    readonly attribute amount : Double;

    readonly attribute date : Date := { Date#today() };

    readonly attribute processed : Date[0,1];

    readonly attribute employee : Employee;

    readonly attribute rejectionReason : Memo[0, 1];

    readonly reference approver : Employee[0, 1];

    port expensePayer : ExpensePayer;

    derived id attribute expenseId : Integer;

    static operation newExpense(description : String, amount : Double, date : Date, 
            category : Category, employee : Employee) : Expense;
    begin
        var newExpense : Expense;
        newExpense := new Expense;
        newExpense.description := description;
        newExpense.amount := amount;
        newExpense.date := date;
        newExpense.category := category;
        newExpense.employee := employee;
        return newExpense;
    end;

    (* Whether this expense qualifies for automatic approval. *)
    derived attribute automaticApproval : Boolean := {
        self.amount < 50
    };
    
    derived attribute daysProcessed : Integer := {
    	if (self.processed == null) then
    	    return 0
    	else
    	    return Date#today().differenceInDays(self.processed);
    };

    operation approve()
        (* Cannot approve own expenses. *)
        precondition { not (System#user() == self.employee) };
    begin
        self.approver := System#user();
    end;
    

    (* Reject this expense. Please provide a reason. *)
    operation reject(reason : Memo)
        (* Cannot reject an expense under the auto-approval limit. *)
        precondition { not self.automaticApproval };
    begin
        self.rejectionReason := reason;
        self.approver := System#user();
    end;
    
    (* Reconsider this expense. *)
    operation reconsider() : Boolean
        (* Cannot reconsider after a week. *)
        precondition { self.daysProcessed < 7 };
    
    (* Sends this expense back to Draft state. *)
    operation review();

    (* Submit this expense. *)
    operation submit() : Boolean;

    private operation reportApproved();
    begin
        send ExpenseApproved(
            employeeName := self.employee.name, 
            amount := self.amount, 
            description := self.description + "(" + self.category.name + ")", 
            expenseId := self.expenseId) to self.expensePayer;
    end;

    static query findExpensesByCategory(category : Category) : Expense[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            e->category == category
        });
    end;

    static query findExpensesInPeriod(start : Date[0, 1], end_ : Date[0, 1]) : Expense[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            ((start == null) or (e.date >= start)) and ((end_ == null) or (e.date <= end_))
        });
    end;

    static query findByStatus(status : Status) : Expense[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            e.status == status
        });
    end;

    (* 
        The different statuses an expense can go through. 
    *)
    statemachine Status

        initial state Draft
            (*
		        If amount is under automatic approval limit,
                the expense is automaticaly approved. 
            *)
            transition on call(submit) to Approved when {
                self.automaticApproval
            };
            transition on call(submit) to Submitted when {
                not self.automaticApproval
            };
        end;

        state Submitted
            transition on call(approve) to Approved;
            transition on call(review) to Draft;
            transition on call(reject) to Rejected;
        end;

        state Approved
            entry {
            	self.processed := Date#today();
                self.reportApproved();
            };
        end;

        state Rejected
            entry {
            	self.processed := Date#today();
            };
            transition on call(reconsider) to Submitted;
        end;

    end;

end;

(* An employee reports expenses. *)
[kirra::User]
class Employee

    attribute name : String;

    attribute expenses : Expense[*];

    derived attribute recordedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Draft)
    };

    derived attribute submittedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Submitted)
    };

    derived attribute approvedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Approved)
    };

    derived attribute rejectedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Rejected)
    };

    derived attribute totalRecorded : Double := {
        self.totalExpenses(self.recordedExpenses)
    };

    derived attribute totalSubmitted : Double := {
        self.totalExpenses(self.submittedExpenses)
    };

    derived attribute totalApproved : Double := {
        self.totalExpenses(self.approvedExpenses)
    };

    derived attribute totalRejected : Double := {
        self.totalExpenses(self.rejectedExpenses)
    };

    operation declareExpense(description : String, amount : Double, date : Date, 
            category : Category) : Expense;
    begin
        return Expense#newExpense(description, amount, date, category, self);
    end;

    private query totalExpenses(toSum : Expense[*]) : Double;
    begin
        return toSum.reduce((e : Expense, sum : Double) : Double {
            sum + e.amount
        }, 0);
    end;

    private query expensesByStatus(status : Expense::Status) : Expense[*]{ordered, unique};
    begin
        return self->expenses.select((e : Expense) : Boolean {
            e.status == status
        });
    end;
end;

association EmployeeExpenses

    role Employee.expenses;

    role Expense.employee;

end;

end.