package expenses;


apply kirra;
import mdd_types;
import payment;

datatype CategoryTotal
    attribute category : Category;
    attribute total : Double;
end;

(* The category for an expense. *)
class Category

    attribute name : String;

    static operation newCategory(name : String) : Category;
    begin 
        var newCategory;
        newCategory := new Category;
        newCategory.name := name;
        return newCategory;
    end; 

    derived attribute expensesInThisCategory : Expense[*] := {
        Expense#findExpensesByCategory(self)
    };
    
    static query totalExpensesPerCategory() : CategoryTotal[*];
    begin
        return Expense extent.groupBy((e : Expense) : Category {
        	e.category
    	}).groupCollect((expenses : Expense[*]) : CategoryTotal {
            {
                category := expenses.one().category, 
                total := expenses.sum((e : Expense) : Double { e.amount })
            }
        });
    end;
    
    static query totalApprovedExpensesPerCategory() : CategoryTotal[*];
    begin
        return Expense extent
        .select((e : Expense) : Boolean {
    		e.status == Expense::Status#Approved 
		}).groupBy((e : Expense) : Category {
        	e.category
    	}).groupCollect((expenses : Expense[*]) : CategoryTotal {
            {
                category := expenses.one().category, 
                total := expenses.sum((e : Expense) : Double { e.amount })
            }
        });
    end;    
    
    static query mostExpensedCategories(threshold : Double) : CategoryTotal[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
    		e.status == Expense::Status#Submitted
		}).groupBy((e : Expense) : Category {
        	e.category
    	}).groupCollect((expenses : Expense[*]) : CategoryTotal {
            {
                category := expenses.one().category, 
                total := expenses.sum((e : Expense) : Double { e.amount })
            }
        }).select((total : CategoryTotal) : Boolean {
        	total.total > threshold
    	});
    end;    

end;

(* The expense as reported by an employee. *)
class Expense 

    derived attribute moniker : String := {
        self.description + " on " + self.date
    };

    readonly attribute description : String;

    readonly reference category : Category;

    readonly attribute status : Status;

    readonly attribute amount : Double;

    readonly attribute date : Date := { Date#today() };

    readonly attribute processed : Date[0,1];

    readonly attribute employee : Employee;

    readonly attribute rejectionReason : Memo[0, 1];

    readonly reference approver : Employee[0, 1];

    port expensePayer : ExpensePayer;

    derived id attribute expenseId : Integer;

    static operation newExpense(description : String, amount : Double, date : Date := { Date#today() }, 
            category : Category, employee : Employee) : Expense;
    begin
        var newExpense;
        newExpense := new Expense;
        newExpense.description := description;
        newExpense.amount := amount;
        newExpense.date := date;
        newExpense.category := category;
        newExpense.employee := employee;
        return newExpense;
    end;

    (* Whether this expense qualifies for automatic approval. *)
    derived attribute automaticApproval : Boolean := {
        self.amount < 50
    };
    
    derived attribute daysProcessed : Integer := {
    	if (self.processed == null) then
    	    return 0
    	else
    	    return Date#today().difference(self.processed).toDays();
    };

    operation approve()
        (* Cannot approve own expenses. *)
        precondition { not (System#user() == self.employee) };
    begin
        self.approver := System#user();
    end;
    

    (* Reject this expense. Please provide a reason. *)
    operation reject(reason : Memo)
        (* Cannot reject an expense under the auto-approval limit. *)
        precondition { not self.automaticApproval };
    begin
        self.rejectionReason := reason;
        self.approver := System#user();
    end;
    
    (* Reconsider this expense. *)
    operation reconsider()
        (* Cannot reconsider after a week. *)
        precondition { self.daysProcessed < 7 };
    
    (* Sends this expense back to Draft state. *)
    operation review();

    (* Submit this expense. *)
    operation submit();

    private operation reportApproved();
    begin
        send ExpenseApproved(
            employeeName := self.employee.name, 
            amount := self.amount, 
            description := self.description + "(" + self.category.name + ")", 
            expenseId := self.expenseId) to self.expensePayer;
    end;

    static query findExpensesByCategory(category : Category) : Expense[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            e->category == category
        });
    end;

    static query findExpensesInPeriod(start : Date[0, 1], end_ : Date[0, 1]) : Expense[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            ((start == null) or (e.date >= start)) and ((end_ == null) or (e.date <= end_))
        });
    end;

    static query findByStatus(status : Status) : Expense[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            e.status == status
        });
    end;
    
    static query pendingExpenses() : Expense[*];
    begin
        return Expense#findByStatus(Status#Submitted);
    end;
    
    static query approvedExpenses() : Expense[*];
    begin
        return Expense#findByStatus(Status#Approved);
    end; 
    
    static query rejectedExpenses() : Expense[*];
    begin
        return Expense#findByStatus(Status#Rejected);    
    end;
    
    static query openExpenseCountPerCategory() : { category : Category, count : Integer }[*];
    begin
        return Expense extent.select((e : Expense) : Boolean {
            e.status == Status#Submitted
        }).groupBy(
        	(e : Expense) : Category { e.category }
    	).groupCollect((group : Expense[*]) : { category : Category, count : Integer } {
        	{
        		category := group.one().category,
        		count := group.size()
    		}
        });
    end;
    
    static query anyPendingExpenses() : Boolean;
    begin
    	return Expense extent.exists((e : Expense) : Boolean {
            e.status == Status#Submitted
        });
    end;

    static query pendingExpenseCount() : Integer;
    begin
    	return Expense extent.count((e : Expense) : Boolean {
            e.status == Status#Submitted
        });
    end;
    
    static query expenseCountPerEmployee() : { employee : Employee, expenseCount : Integer }[*];
    begin
        return Expense extent.groupBy(
        	(e : Expense) : Employee { e.employee }
    	).groupCollect((group : Expense[*]) : { employee : Employee, expenseCount : Integer } {
        	{
        		employee := group.one().employee,
        		expenseCount := group.size()
    		}
        });
    end;
    
    static query expenseDetails() : { reporter : Employee, category: String, expenseAmount : Double }[*];
    begin
        return Expense extent.collect((e : Expense) : { reporter : Employee, category : String, expenseAmount : Double } {
        	{
        		reporter := e.employee,
        		category := e.category.name,
        		expenseAmount := e.amount
    		}
        });
    end;


    (* 
        The different statuses an expense can go through. 
    *)
    statemachine Status

        initial state Draft
            (*
		        If amount is under automatic approval limit,
                the expense is automaticaly approved. 
            *)
            transition on call(submit) to Approved when {
                self.automaticApproval
            };
            transition on call(submit) to Submitted when {
                not self.automaticApproval
            };
        end;

        state Submitted
            transition on call(approve) to Approved;
            transition on call(review) to Draft;
            transition on call(reject) to Rejected;
        end;

        state Approved
            entry {
            	self.processed := Date#today();
                self.reportApproved();
            };
        end;

        state Rejected
            entry {
            	self.processed := Date#today();
            };
            transition on call(reconsider) to Submitted;
        end;

    end;

end;

(* An employee reports expenses. *)
[kirra::User]
class Employee

    attribute name : String;
    
    readonly id attribute username : String;

    attribute expenses : Expense[*];

    derived attribute recordedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Draft)
    };

    derived attribute submittedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Submitted)
    };

    derived attribute approvedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Approved)
    };

    derived attribute rejectedExpenses : Expense[*] := {
        self.expensesByStatus(Expense::Status#Rejected)
    };

    derived attribute totalRecorded : Double := {
        self.recordedExpenses.sum((e : Expense) : Double { e.amount })
    };

    derived attribute totalSubmitted : Double := {
        self.submittedExpenses.sum((e : Expense) : Double { e.amount })        
    };

    derived attribute totalApproved : Double := {
        self.approvedExpenses.sum((e : Expense) : Double { e.amount })        
    };

    derived attribute totalRejected : Double := {
        self.rejectedExpenses.sum((e : Expense) : Double { e.amount })                
    };

    operation declareExpense(description : String, amount : Double, date : Date, 
            category : Category) : Expense;
    begin
        return Expense#newExpense(description, amount, date, category, self);
    end;

    private query totalExpenses(toSum : Expense[*]) : Double;
    begin
        return toSum.reduce((e : Expense, sum : Double) : Double {
            sum + e.amount
        }, 0.0);
    end;

    private query expensesByStatus(status : Expense::Status) : Expense[*]{ordered, unique};
    begin
        return self->expenses.select((e : Expense) : Boolean {
            e.status == status
        });
    end;
    
    static query employeesWithNoExpenses() : Employee[*];
    begin
    	return Employee extent.select((e : Employee) : Boolean {
            e.expenses.isEmpty()
        });
    end;
    
    operation deleteEmployee();
    begin
        self.expenses.forEach((e : Expense) { destroy e; });
        destroy self;
    end;

end;

association EmployeeExpenses

    role Employee.expenses;

    role Expense.employee;

end;

end.